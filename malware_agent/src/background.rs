// Ziel: Prozess im Hintergrund ausführen

use anyhow::Result;

/// Versetzt das Programm in den Hintergrund
///
/// # Unix
/// Verhält sich wie die Python 'daemonize' Funktion (Double Fork).
///
/// # Windows
/// Da Windows kein fork() untersützt, ist die übliche Methode,
/// das Programm ohne Konsolenfenster zu kompilieren (#![windows_subsystem = "windwos"])
/// oder das Fenster programmgesteuert zu verstecken.
pub fn daemonize_process() -> Result<()> {
    daemonize_internal()
}

// UNix logik
#[cfg(unix)]
fn daemonize_internal() -> Result<()> {
    // IM test darf nicht wirklich geforkt werden, sonst stürzt der Test-Runner (cargo test) ab
    #[cfg(test)]
    {
        println!("TEST-MODE: Deamonize wird simuliert (Kein echter fork)");
        return Ok(());
    }
    #[cfg(not(test))]
    {
        // Versucht, den Prozess zud daemonisieren (stdout/stderr ignorieren oder umleiten)
        daemonize::Daemonize::new()
            .working_directory("/")
            .start()
            .map_err(|e| anyhow::anyhow!("Daemonize failed: {}", e))?;

        Ok(())
    }
}

// Windows logik
#[cfg(windows)]
fn daemonize_internal() -> Result<()> {
    // Unter Windows macht das Attribut #![windows_subsystem = "windows"] in main.rs die Arbeit.
    // Wir müssen hier zur Laufzeit nichts tun.
    // Optional könnte man hier prüfen, ob man wirklich detached ist, ist aber meist unnötig.
    Ok(())
}

// Fallback: Andere Systeme
#[cfg(not(any(unix, windows)))]
fn daemonize_internal() -> Result<()> {
    Ok(())
}

// Tests
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_daemonize_call_does_not_crash() {
        // Prüft, ob die Funktion aufgerufen werden kann, ohne das der Test-Prozess abstürut
        let result = daemonize_process();

        assert!(
            result.is_ok(),
            "Daemonize Funktion sollte im Test-Modus Ok zurückgeben"
        );
    }

    #[test]
    #[cfg(unix)]
    fn test_unix_specifics() {
        // aber da wir 'daemonize' mocken, prüfen wir nur die Erreichbarkeit.
        let result = daemonize_internal();
        assert!(result.is_ok());
    }

    #[test]
    #[cfg(windows)]
    fn test_windows_placeholder() {
        // Unter Windows ist es ein No-Op, muss also immer Ok sein.
        let result = daemonize_internal();
        assert!(result.is_ok());
    }
}
