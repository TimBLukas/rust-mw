// Ziel: Prozess im Hintergrund ausf체hren

use anyhow::Result;

/// Versetzt das Programm in den Hintergrund
///
/// # Unix
/// Verh채lt sich wie die Python 'daemonize' Funktion (Double Fork).
///
/// # Windows
/// Da Windows kein fork() unters체tzt, ist die 체bliche Methode,
/// das Programm ohne Konsolenfenster zu kompilieren (#![windows_subsystem = "windwos"])
/// oder das Fenster programmgesteuert zu verstecken.
pub fn daemonize_process() -> Result<()> {
    #[cfg(unix)]
    {
        // Versucht, den Prozess zud daemonisieren (stdout/stderr ignorieren oder umleiten)
        daemonize::Daemonize::new()
            .working_directory("/")
            .start()
            .map_err(|e| anyhow::anyhow!("Daemonize failed: {}", e))?;

        Ok(())
    }

    #[cfg(windows)]
    {
        // Unter Windows wird mit einer Linker-Flag in main.rs gearbeitet
        // Wenn das zur Laufzeit gemacht werden soll (weniger sauber):
        use std::ptr;
        unsafe {
            let kernel32 = std::ffi::CString::new("kernel32.dll").unwrap();
            let user32 = std::ffi::CString::new("user32.dll").unwrap();

            // Minimalistische Methode, um die Ausgaben zu versteeken
            // -> Besser ist aber das ganze in main.rs zu machen
        }

        Ok(())
    }
}
