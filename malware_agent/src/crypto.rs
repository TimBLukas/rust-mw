use aes::cipher::{KeyIvInit, StreamCipher};
use anyhow::{Context, Result};
use rand::{Rng, rng};
use std::fs::{self, File};
use std::io::{BufReader, BufWriter, Read, Write};
use std::path::Path;

// Typ-Alias für AES-256 im CTR-Modus
type Aes256Ctr = ctr::Ctr64BE<aes::Aes256>;

/// Generiert einen kryptographisch sicheren 256-Bit Schlüssel und speichert diesen.
///
/// # Arguments
/// * `base_path` - Verzeichnis, in dem die Schlüsseldatei `rescue.key` abgelegt wird.
///
/// # Returns
/// Gibt den 32-Byte Schlüssel zurück.
pub fn generate_and_save_key(base_path: &Path) -> Result<[u8; 32]> {
    let mut key = [0u8; 32];
    rng().fill(&mut key);

    let key_path = base_path.join("rescue.key");

    fs::write(&key_path, &key)
        .with_context(|| format!("Fehler beim Schreiben der Schlüsseldatei: {:?}", key_path))?;

    Ok(key)
}

/// Verschlüsselt eine Datei mit AES-256-CTR.
///
/// Die Datei wird stückweise (streaming) gelesen, verschlüsselt und in eine temporäre Datei geschrieben.
/// Nach erfolgreichem Abschluss wird die Originaldatei durch die verschlüsselte Version ersetzt (atomare Operation).
///
/// # Arguments
/// * `path` - Pfad zur zu verschlüsselnden Datei.
/// * `key` - Der 32-Byte AES-Schlüssel.
/// * `iv` - Der 16-Byte Initialisierungsvektor.
pub fn encrypt_file_atomic(path: &Path, key: &[u8; 32], iv: &[u8; 16]) -> Result<()> {
    let input_file = File::open(path).context("Konnte Eingabedatei nicht öffnen")?;
    let mut reader = BufReader::new(input_file);

    let temp_path = path.with_extension("enc_temp");
    let output_file = File::create(&temp_path).context("Konnte temporäre Datei nicht erstellen")?;
    let mut writer = BufWriter::new(output_file);

    let mut cipher = Aes256Ctr::new(key.into(), iv.into());
    let mut buffer = [0u8; 4096];

    loop {
        let count = reader.read(&mut buffer)?;
        if count == 0 {
            break;
        }
        let chunk = &mut buffer[..count];
        cipher.apply_keystream(chunk);
        writer.write_all(chunk)?;
    }

    writer.flush()?;

    // Wichtig: Reader und Writer droppen, um File-Handles freizugeben, bevor umbenannt wird (besonders wichtig unter Windows)
    drop(reader);
    drop(writer);

    fs::rename(&temp_path, path.with_extension("locked"))
        .context("Fehler beim atomaren Ersetzen der Datei")?;

    // Versuchen, die Originaldatei zu löschen, falls rename nicht implizit löscht (Systemabhängig),
    // meistens reicht rename, aber falls die temp Datei woanders lag:
    if path.exists() {
        let _ = fs::remove_file(path);
    }

    Ok(())
}

/// Entschlüsselt eine .locked Datei und stellt das Original wieder her.
///
/// # Arguments
/// * `path`- Pfad zur verschlüsselten Datei (muss auf .locked enden).
/// * `key` - Der AES-Schlüssel aus der rescue.key Datei.
/// * `iv` - Der Initialisierungsvektor (muss identisch zu dem bei der verschlüsselung verwendeten
/// sein
pub fn decrypt_file_atomic(path: &Path, key: &[u8; 32], iv: &[u8; 16]) -> Result<()> {
    // Checken ob es sich um eine .locked Datei handelt
    if path.extension().and_then(|e| e.to_str()) != Some("locked") {
        // Nicht verschlüsselte Datei ignorieren
        return Ok(());
    }

    // Zielpfad bestimmen (Endung .locked entfernen)
    let original_path = path.with_extension("");
    let input_file = File::open(path).context("Konnte .locked Datei nicht öffnen")?;
    let mut reader = BufReader::new(input_file);

    // Zunächst in temp-Datei
    let temp_path = original_path.with_extension("dec_temp");
    let output_file = File::create(&temp_path).context("Zieldatei konnte nicht erstellt werden")?;
    let mut writer = BufWriter::new(output_file);

    // Bei AES: Entschlüsselung mathematisch identisch zur Verschlüsselung
    let mut cipher = Aes256Ctr::new(key.into(), iv.into());
    let mut buffer = [0u8; 4096];

    loop {
        let count = reader.read(&mut buffer)?;
        if count == 0 {
            break;
        }

        let chunk = &mut buffer[..count];
        // XOR ist umkehrbar -> gleicher aufruf
        cipher.apply_keystream(chunk);
        writer.write_all(chunk)?;
    }

    writer.flush()?;
    drop(reader);
    drop(writer);

    // Datei umbenennen (Temp -> Original)
    fs::rename(&temp_path, &original_path)
        .context("Fehler beim Wiederherstellen der ursprünglichen Datei");

    // Locked Datei löschen
    if path.exists() {
        let _ = fs::remove_file(path);
    }

    Ok(())
}
